÷／所以1÷1＝多少啊！／小朋友们！1除1等于1噢！除以1等于1，因为在数学中我们规定，任何数除以它本身等于1，1除以任何分数等于这个分数的倒数。由于除以一即为一个数除以它本身，故等于1，所以一除以一等于一！ 辣么，我们来稍微深入一下，为什么1÷1＝1呢！ 让我们欢迎数学科任老师！有他来为大家讲解！ *鼓掌*鼓掌 . 为什么1÷1=1 ？ 思路： . 1．思考 “如果不等于1，会有什么后果？”（即反证法） . 2.并用数值的方法求解。 . 3.数学形式表达问题并作出推广。 ·1.解：形式上是a÷b=c的问题（其中b≠0）。反证：如果商不为c，而为不同于c的c_1，那么c_1×b=a_1，a_1与a就必然不等（因为a_1-a=c_1×b-a=b(c_1-c)≠0）;根据乘除可逆性质，一旦不等，就说明c_1不能是a÷b的结果。满足b×c=a的c才是a÷b的唯一解。 . 2.如果没有除法运算，当b×c=a，已知a、b，欲求c时。分析：这看起来不算是个问题，例如知道a=1、b=2，想知道c，人们可以一口答出c=2；但是如果a=3.12、b=1.23，想知道c呢？（不能用除法）。我们通常会试着求解：如果c=1，那么b×c就大于a了，因此c应该比1小；如果c=0，那么b×c就小于a了，因此c应该比0大；由此可以得到c的值应该在0与1之间。人们会很自然地想到下一步再试试0.5，就这样用二分的思想一步步逼近精确的解。 . 可能至此有人会问，为什么最开始试的c是1和0呢？然后在这个区间进行二分，如果a=21431234、b=12312，根本看不出来c在什么取值区间呢？还是这个例子，数值方法上的解法是，先假设结果是一个随机值，比如c=1，很显然等式不成立，且小很多。无妨，作以下假设，如果c=1，那么a=b×c=12312，与实际已知的a存在着偏差，因此需要对c进行调节使得解合理，这个偏差越大说明我们需要调节的幅度就越大，当然偏差越小我们就只需要微调一下c就能很快地得到一个较好的c使得等式a=b×c成立。当设定调节的幅度正比于偏差时，这便是梯度下降的思想。 . 3.用数学形式写一下： 问题描述：等式a=bc成立，且已知a、b，欲求c。 推导：等式左右同时左乘上b(-1)，得到c=b(-1) a，当b为一数值时，b^(-1) 就是 1/b 即对b求倒数，因此c=a/b，我们把当b为数值是的这个等式定义为除法。如果b是一个矩阵呢，b(-1)表示的就是对矩阵b求逆，还是写成c=b(-1) a的形式。 . 就像求倒数已经很容易实现一样，求逆也有一套标准的方法；前者要求分母不为0，后者要求可逆即矩阵非奇异。当分母很大时，计算机还是能就很快地求倒数；但是到矩阵这一块就难以满足了，当矩阵维度、大小很大时，求逆会消耗大量的时间。因此数值上的解法，不失为求取c的另外一种方法。 · 总结： 对于0维的矩阵（数值），存在数值的求商解法； 对于2维的矩阵（普通矩阵），也存在数值的求商解法； 推广，其实1维的矩阵（向量），也存在数值的求商解法（见后文程序2）；多维的亦然。 这些不同维度的是不是都有除法的定义以及b^(-1)的表达呢？ . 换一个角度想，其实均是针对二维的: 数值是大小为1×1的二维矩阵，向量是1×n或n×1的二维矩阵，常规意义上的矩阵行列都大于1罢了。 · 迭代之前的讨论： 连续吗？怎么找到那个迭代方向（能够收敛地逼近最优解）？ 很明显，如果是非连续的，最优解可能在任何的一个取值点，除非比对每个点的取值，不然是不可能确定得到的就是最优的。此时所有的算法都是不可能的。 当函数是连续的（哪怕是局部连续的），我们能通过一定的算法找到最优解。但是所有算法都得考虑这样一个问题：在求解的过程中，是不是越来越逼近最优解？然后最终能收敛不？ 对于一个寻优问题，可以抽象到一个最简单的表达式y=f(x)，要找到一个最优的自变量x使得经过f(∙)映射能取到想要的y。 例如：max y=f(x),x无限制 或者：min e=|f(x)-g|,x无限制,g为构造的可能接近最大值的一个表达式 整个问题形式包括：自变量、目标函数、限制条件。 因此，1÷1＝1呢！ *鼓掌 太精彩辣！让我们谢谢@bighead_boy老师的讲解！老师的讲解十分深入浅出专业谐趣！ *鼓掌 （附上资料原文链接：https://blog.csdn.net/qq_22465641/article/details/99971705）／／／／／2024-8-25